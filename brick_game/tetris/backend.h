/// @mainpage
/// @file backend.h
/// @author hornedsi
/// @brief Игра тетрис (бэк)
/// @version 1.0
/// @date 01.08.2024
///
/// @copyright Copyright (c) 2024

#ifndef BACKEND_H
#define BACKEND_H

#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define GAME 1

/// @brief Перечисление пользовательских действий
/// @param Start нажатие кнопки "Старт"
/// @param Pause нажатие кнопки "Пауза"
/// @param Terminate нажатие кнопки "Прекратить"
/// @param Left нажатие кнопки "Лево"
/// @param Right нажатие кнопки "Право"
/// @param Up нажатие кнопки "Вверх"
/// @param Down нажатие кнопки "Вниз"
/// @param Action нажатие кнопки "Действие"
typedef enum {
  Start,
  Pause,
  Terminate,
  Left,
  Right,
  Up,
  Down,
  Action
} UserAction_t;

/// @brief Перечисление состояний конечного автомата
/// @param START состояние, в котором игра ждет, пока игрок нажмет кнопку
/// готовности к игре.
/// @param SPAWN состояние, в которое переходит игра при
/// создании очередного блока и выбора следующего блока для спавна.
/// @param MOVING основное игровое состояние с обработкой ввода от пользователя
/// — поворот блоков/перемещение блоков по горизонтали.
/// @param SHIFTING состояние, в которое переходит игра после истечения таймера.
/// В нем текущий блок перемещается вниз на один уровень. При невозможности игра
/// заканчивается.
/// @param PAUSE состояние, в котором игра ждет , пока игрок нажмет кнопку паузы
/// @param ATTACHING состояние, в которое преходит игра после «соприкосновения»
/// текущего блока с уже упавшими или с землей. Если образуются заполненные
/// линии, то она уничтожается, и остальные блоки смещаются вниз.
/// @param EXIT состояние, когда осуществляется выход из игры.
/// @param GAMEOVER состояние, когда игра окончена.
typedef enum {
  START = 0,
  SPAWN,
  MOVING,
  SHIFTING,
  PAUSE,
  ATTACHING,
  EXIT,
  GAMEOVER
} game_state_t;

/// @brief Структура игрового состояния
/// @param field Двумерный массив поля
/// @param next Двумерный массив следующейфигуры
/// @param score Счёт игры
/// @param high_score Максимальный рекорд
/// @param level Текущий уровень
/// @param speed Текущий скорость
/// @param pause Пауза игры
typedef struct {
  int **field;
  int **next;
  int score;
  int high_score;
  int level;
  int speed;
  int pause;
} GameInfo_t;

/// @brief Структура с переменными конечного автомата
/// @param game_state Переменная состояний конечного автомата
/// @param service Сервисная переменная
typedef struct {
  game_state_t game_state;
  bool service;
} game_t;

/// @brief Структура тгровой фигуры
/// @param brick Ссылка на двумерный массив с фигурой
/// @param pos_x Положение фигуры по оси х
/// @param pos_y Положение фигуры по оси у
typedef struct {
  int **brick;
  int pos_x;
  int pos_y;
} curr_brick_t;

/// Размер массива с Фигурами
#define NEXT_SIZE 5

/// Количество фигур
#define BRICK_COUNT 7

/// Ширина игрового поля
#define W_SIZE 10

/// Высота игрового поля
#define H_SIZE 20

/// Путь файла с игровым рекордом
#define SCORE_FILE "score.data"

/// @brief Проверка ввода с клавиатуры и применение необходимой функции к игре.
/// В зависимости от ввода пользователя осуществляет выбор состояния КА и вызов
/// соответствующей функции.
/// @param action Действие, которое совершил игрок
/// @param hold Дополнительный параметр, который отвечает за зажатие клавиши
void userInput(UserAction_t action, bool hold);

/// @brief Функция предназначена для получения данных для отрисовки в
/// интерфейсе. Эта функция создаёт временное игровое поле с отражением текущего
/// состояния игры и фигуры.
/// @return Копия текущего состояния игры, куда записано положение фигуры игрока
/// на поле
GameInfo_t updateCurrentState();

/// @brief Функция обнуления массива
/// @param array Двойной указатель на массив
/// @param row Количество строк
/// @param column Количество столбцов
void s21_array_zero(int **array, int row, int column);

/// @brief Функция случайной инициализации следующей фигуры
/// @param next Двойной указатель на массив следующей фигуры
void s21_init_shape(int **next);

/// @brief Функция получения состояния конечного автомата
/// @return Адрес структуры с переменными конечного автомата
game_t *s21_get_state();

/// @brief Функция получения игрового состояния
/// @return Указатель на текущее игровое состояние
GameInfo_t *s21_get_game_info();

/// @brief Функция получения фигуры на игровом поле
/// @return Указатель на структуру с фигурой
curr_brick_t *s21_get_brick();

/// @brief Функция получения следующей фигуры
/// @return Указатель на структуру с фигурой
curr_brick_t *s21_get_next();

/// @brief Функция по проверки пересечения фигуры с полем
/// @param pos_x Позиция клетки поля относительно массива фигуры по х
/// @param pos_y Позиция клетки поля относительно массива фигуры по у
/// @param cel Значение в указанной точке поля
/// @param brick Указатель на массив с фигурой
/// @return Возвращает 0 - если нет пересечения, 1 - если есть пересечение
int s21_check_colission_with_field(int pos_x, int pos_y, int cel, int **brick);

/// @brief Функция проверки пересечения с полем или нижней границей поля
/// @param brick Указатель на массив с фигурой
/// @param pos_x Положение фигуры по х
/// @param pos_y Положения фигуры по у
/// @return Возвращает 0 - если нет пересечения 1 если есть пересечение
int s21_check_colission(int **brick, int pos_x, int pos_y);

/// @brief Функция проверки где у фигуры находится левый или правый край в
/// массиве
/// @param wall Переменная отвечающая за поиск соответствующего края
/// @return Координата по х относительно массива фигуры, где находится
/// соотвествтвующий край
int s21_check_brick_pos(int wall);

/// @brief Функция выполняющая перемещение в указанном направлении
/// @param dir Направление перемещения
void s21_move(int dir);

/// @brief Функция трансформирования двумерного массива в массив указателей
/// @param buff Исходный массив размером row * col
/// @param matr Массив указателей row, куда будут записаны указатели на строки
/// @param row Количество строк
/// @param col Количество столбцов
void s21_transform(int *buff, int **matr, int row, int col);

/// @brief Копирует матрицу полностью
/// @param dir Куда копировать матрицу
/// @param source Откуда копировать матрицу
/// @param row Количество строк
/// @param col Количество столбцов
void s21_copy_matrix(int **dir, int **source, int row, int col);

/// @brief Функция копирования фигуры, копирует из массива только не нулевые
/// значения
/// @param orig Куда должен быть записан массив
/// @param next Откуда должен быть получен массив
/// @param x Положение массива next относительно массива orig по х
/// @param y Положение массива next относительно массива orig по у
void s21_copy_figure(int **orig, int **next, int x, int y);

/// @brief Функция выполняющая вращение фигуры
void s21_action();

/// @brief Функция стартового состояния КА (ждёт ввода от пользователя). При
/// инициализации пользователем инициализируется игровое состояние КА и конечный
/// автомат переходит в состояние создания очередного блока.
/// @param sig Сигнал от пользователя
/// @param state Указатель на состояние конечного автомата
void s21_start_state(UserAction_t sig, game_state_t *state);

/// @brief Функция состояния КА генерирования следующего игрового блока
/// (автоматически меняет состояние КА). Если следующий блок имеет столкновение
/// с элементом игрового поля, то КА переходит в состояние окончания, если нет,
/// то КА переходит в основное игровое состояние.
/// @param state Указатель на состояние конечного автомата
/// @param status Указатель на структуру игрового состояния
void s21_spawn_state(game_state_t *state, GameInfo_t *status);

/// @brief Функция основного состояния КА (ждёт ввода от пользователя и
/// автоматически меняет состояние КА). В зависимости от ввода пользователя
/// осуществляет перемещение фигуры по горизонтали и вниз, а тагже поворот
/// фигуры. Автоматически по таймеру переводит КА в состояние перемещения
/// блока вниз.
/// @param sig Сигнал от пользователя
/// @param state Указатель на состояние конечного автомата
/// @param status Указатель на структуру игрового состояния
void s21_moving_state(UserAction_t sig, game_state_t *state,
                      GameInfo_t *status);

/// @brief Функция состояния КА перемещения блока вниз (автоматически меняет
/// состояние КА). При возможности перемещения вниз фигуры перемещает её и
/// переводит КА в основное состояние. В противном случае переводит КА в
/// состояние присоединения блока.
/// @param state Указатель на состояние конечного автомата
void s21_shifting_state(game_state_t *state);

/// @brief Функция состояния КА паузы (ждёт ввода от пользователя). По действию
/// пользователя переводит КА в основное состояние. Отслеживает соответствующее
/// значение состояния игры.
/// @param sig Сигнал от пользователя
/// @param state Указатель на состояние конечного автомата
/// @param status Указатель на структуру игрового состояния
void s21_pause_state(UserAction_t sig, game_state_t *state, GameInfo_t *status);

/// @brief Функция состояния КА присоединения блока (автоматически меняет
/// состояние КА). Осуществляет проверку заполнений линий игрового поля,
/// достижения уровня и перезаписывает рекорд. Копирует присоединяемую фигуру на
/// игровое поле и переводит КА в состояние генерирования следующего игрового
/// блока.
/// @param state Указатель на состояние конечного автомата
/// @param status Указатель на структуру игрового состояния
void s21_attaching_state(game_state_t *state, GameInfo_t *status);

/// @brief Функция состояния КА окончания игры (автоматически меняет состояние
/// КА). При выборе пользователем продолжения игры очищает игровое поле и
/// переводит КА в стартовое состояние.
/// @param sig Сигнал от пользователя
/// @param state Указатель на состояние конечного автомата
/// @param status Указатель на структуру игрового состояния
void s21_gameover_state(UserAction_t sig, game_state_t *state,
                        GameInfo_t *status);

/// @brief Копирует текущее состояние игры и фигуры на игровое поле
/// @param field Указатель на матрицу, куда нужно скопировать
void s21_copy_game(int **field);

/// @brief Функция инициализации игрового состояния
void s21_init_status();

/// @brief Функция перемещения фигуры вниз, и проверки пересечения с дном или
/// полем
/// @return Возвращает 1 в случае успешного перемещения 0 в случае пересечения
int s21_step_down();

/// @brief Удаляет указанную строку и смещает поле вниз
/// @param row Строка, которую нужно удалить
void s21_move_field_down(int row);

/// @brief Функция проверки заполненности строк, увеличения счёта и рекорда.
void s21_check_lines();

/// @brief Функция проверки и изменения уровня.
void s21_check_level();

/// @brief Функция записи рекорда в файл
void s21_record_score();

#endif